# 1주차

# 01 HTTP 리퀘스트 메시지를 작성한다.

---

## 1 .탐험 여행은 URL 입력부터 시작한다.

- 브라우저는 다양한 기능을 지원하며, 이에 따라 URL 형식도 다름
    - 예: `http:`, `ftp:`, `file:`, `mailto:` 등
- URL은 액세스 대상에 따라 도메인명과 경로명을 포함함
- URL의 맨 앞 문자열은 액세스 방법을 나타냄

## 2. 브라우저는 먼저 URL을 해독한다.

- 브라우저는 웹서버에 리퀘스트 메시지를 보내기 위해 URL을 해독
- 예제: `https://www.lab.cyber.co.kr/dir1/file1.html`
    - `https:` → 프로토콜
    - `//` → 구분자
    - `www.lab.cyber.co.kr` → 웹 서버명
    - `/dir1/file1.html` → 데이터 출처의 경로명

## 3. 파일명을 생략한 경우

- URL이 `/`로 끝나는 경우, `index.html` 또는 `default.htm`을 기본 파일로 처리
- 예제:
    - `https://www.lab.cyber.co.kr/dir1/` → `/dir1/index.html`로 해석
    - `https://www.lab.cyber.co.kr` → `/index.html`로 해석
    - `https://www.lab.cyber.co.kr/whatisthis` → 파일 또는 디렉토리 여부에 따라 해석됨

## 4. HTTP의 기본 개념

HTTP프로토콜은 클라이언트와 서버가 주고받는 메시지의 내용이나 순서를 정한 것으로, 

**1. 먼저 클라이언트에서 서버를 향해 ‘무엇을(URL)’, ‘어떻게 해서(메소드)’ 라는 내용의 리퀘스트 메시지를 웹서버로  보냄**

- URL
    - 파일이름이나 , CGI 프로그램의 파일명, http:로 시작하는 url 등
- 메소드
    - 웹 서버에 어떤 동작을  하고 싶은지 전달
    - URL로 나타낸 데이터를 읽고 싶다, 전달하고 싶다 등
1. **웹서버는 요청을 해독하고 결과 데이터(헤더 파일과 페이지의 데이터)를 응답 메시지를 생성하여 클라이언트에 반환**
- 응답 메시지
    - 맨 앞에 실행결과가 정상종료인지 이상이 있는지 나타내는 스테이터스 코드가 있음
    - ex) 404 Not Found
1. **클라이언트는 메시지의 데이터를 추출하여 화면에 표시하면서 HTTP의 동작 마무리**

![image.png](1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%201b1604d1c8f2806ca6a2c3cdcd1164ea/image.png)

- **GET**: 지정된 페이지 데이터를 요청
- **POST**: 입력 데이터를 서버에 송신
    - get 이후 페이지의 데이터를 저장한 파일의 이름을 쓰면 파일의 데이터를 읽으라는 의미

## 5. HTTP 리퀘스트 메시지를 만든다.

URL을 해독하고 웹 서버와 파일명을 판단하면 브라우저는 이것을 바탕으로 HTTP의 리퀘스트 메시지를 만든다.

- HTTP 메시지의 포맷
    - 첫번째 행 : 리퀘스트 라인
        - 맨 앞에는 메소드의 결정방식이 작성
        - URL
    - 두번째 행 : 메시지 헤더
        - 첫번째 행의 부가적인 자세한 내용
    - 메시지 헤더 이후 공백 행 그리고 송신할 데이터 : 메시지 본문

## 6. 리퀘스트 메시지를 보내면 응답이 되돌아 온다.

응답 메시지의 포맷도 기본적인 개념은 리퀘스트 메시지와 같지만, 첫번째 행이 다르다.

응답의 경우는 리퀘스트의 실행결과(정상종료, 오류발생) 를 나타내는 스테이터스 코드와 응답문구를

첫번째 행에 써야한다.

- 스테이터스 코드
    - 숫자
    - 프로그램 등에 실행 결과를 알려주는 것이 목적
- 응답 문구
    - 문장
    - 사람에게 실행결과를 알리는 것이 목적

응답 메시지가 되돌아오면 데이터를 추출한 후 화면에 효시하여 웹 페이지를 눈으로 확인 가능

(페이지가 문장으로 되어있을 경우)

# 02 웹서버의 IP 주소를 DNS 서버에 조회한다.

---

## 1. IP 주소의 기본

HTTP의 메시지를 만들면 이것을 OS에 의뢰하여 액세스 대상의 웹 서버에게 송신.

- 브라우저는 URL을 해독하거나 HTTP 메시지를 만들지만, 네트워크에 송출하는 기능이 없기 때문에
    
    OS에 의뢰하여 송신.
    
- URL안에 쓰여있는 서버의 도메인 명에서 IP주소를 조사
    - OS에 송신을 의뢰할때는 IP 주소로 받을 상대를 지정

### IP주소(네트워크 주소 + 호스트 번호)

- TCP/IP
    - 서브넷이라는 작은 네트워크를 라우터로 접속하여 전체 네트워크의 모습
- 00동 00번지 라는 형태로 네트워크의 주소를 할당할때
    - 00동은 네트워크 번호로 서브넷에 할당
    - 00번지는 호스트 번호 로 컴퓨터에 할당
- 기본적인 개념
    - 송신측이 메시지를 보내면 서브넷 안에 있는 허브가 운반, 송신측에서 가장 가까운 라우터에 도착,
    - 라우터가 메시지를 보낸 상대를 확인하여 다음 라우터 판단하고 지시하여 송신동작 실행  ⇒ 전체반복
- 32 비트의 디지털 데이터인 IP주소를 네트워크 번호와 호스트 번호로 구분하기 위해 넷마스크 사용
    - 호스트 번호
        - 모두 0 : 서브넷 자체를 나타냄
        - 모두 1 : 서브넷에 있는 기기 전체에 패킷을 보내는 ‘브로드캐스트’를 나타냄
            
            ![image.png](1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%201b1604d1c8f2806ca6a2c3cdcd1164ea/image%201.png)
            

## 도메인명과 IP주소를 구분하여 사용하는 이유

- 사람이 기억하기 쉽게 도메인명을 사용
- DNS를 통해 도메인명과 IP 주소를 매핑
    - 실제로 서버명 대신 IP 주소를 써도 올바르게 작동함
    - 하지만 IP주소는 기억하기 어렵기 때문에 서버명을 쓰는 것이 좋음

## 3. Socket 라이브러리가 IP주소를 찾는 기능을 제공한다.

DNS 서버에 조회한다는 것은 DNS 서버에 조회 메시지를 보내고, 거기에서 반송되는 응답 메시지를 받는 다는 것,

이것은 DNS 서버에 대해 클라이언트로 동작한다는 의미이다.

- DNS 클라이언트 = DNS 리졸버, 리졸버
- DNS 원리로 IP주소를 조사하는 것 = 네임 리졸루션
- 리졸루션의 실행하는 것 = 리졸버 = Socket 라이브러리에 들어있는 부품화한 프로그램

- Socket라이브러리
    - 다양한 애플리케이션을 이용할 수 있도록 부품화한 여러 개의 프로그램을 모아놓은 것.
    - OS에 포함되어 있는 네트워크 기능을 애플리케이션에서 호출하기 위한 부품을 모아놓은 것.
    - 리졸브는 그 중 하나.

## 4. 리졸버를 이용하여 DNS 서버를 조회한다.

- 과정
    - 메모리 영역에서 ‘리졸버 프로그램 명’과 ‘웹 서버의 이름’을 쓰기만 하면 리졸버 호출 (리졸버가 DNS 서버에 조회 메시지를 보내고)
    - 메모리 영역에 IP주소 기입( DNS 서버에서 응답 메시지가 돌아오는데 이 메시지에 IP주소 포함)

## 5. 리졸버 내부의 작동

1. 네트워크 애플리케이션(여기선 브라우저)이 리졸버를 호출하면 호출처의 프로그램이 쉬고 있는 상태가 되고, 호출한 대상인 리졸버가 움직이기 시작한다.
2. 리졸버로 제어가 넘어가면 DNS 서버에 문의하기 위한 메시지를 만든다 (= HTTP의 리퀘스트 메시지와 유사)
3. 메시지를 DNS 서버에 보내는데 리졸버도 송수신 기능이 없기 때문에 이것은 OS의 내부에 포함된 프로토콜 스택을 호출하여 실행을 의뢰.
4. 프로토콜 스택이 LAN 어댑터를 통해 메시지가 DNS서버를 향해 송신
5. 이때 액세스 대상의 웹서버가 DNS 서버에 등록되어 있으면 답을 응답메시지에 써서 클라이언트에게 반송
6. 메시지는 클라이언트측에 도착하고, 프로토콜 스택을 통해 리졸버에게 건네져 리졸버가 내용을 해독하여 IP주소를 추출하여 애플리케이션에 제공
7. 이후 리졸버의 동작이 끝나고 제어가 애플리케이션에 돌아간다.

# 03 전세계의 DNS 서버가 연대한다.

---

## 1. DNS 서버의 기본 동작

클라이언트에서 조회 메시지를 받고 조회의 내용에 응답하는 형태로 정보를 회답하는일

- 조회 메시지
    - 이름
    - 클래스
    - 타입
- 예제: `www.lab.cyber.co.kr`
    - 이름 = www.lab.cyber.co.kr
    - 클래스 = IN
    - 타입 = A
    - 그럼 DNS 서버는 등록된 정보에서 세가지가 일치하는 것을 찾아 회답

## 2. 도메인의 계층

DNS서버에 정보가 등록되어 있지 않는 경우에는 정보를 분산시켜 다수의 DNS서버에 등록하고, 다수의 DNS 서버가 연대하여 어디에 정보가 등록되어 있는지를 찾아내는 구조.

- DNS서버에 등록한 정보에는 모든 도메인 명이라는 계층적 구조를 가진 이름이 붙여져있다.
- 계층은 회사의 사업부, 회계부 같은 부라 생각, 여기서 부는 .으로 표현
- 오른쪽에 위치한 것이 상위계층
    - 예제: `www.lab.cyber.co.kr`
        - com 사업부
        - cyber 사업부
        - lab 사업부
        - www 사업부
        - 여기서 하나의 부서가 도메인
- 한대의 DNS의 서버에 도메인 한대
- 도메인아래 하위 도메인 할당 가능.

## 3. 담당 DNS 서버를 찾아 IP주소를 가져온다.

하위의 도메인을 담당하는 DNS서버의 IP 주소를 그 상위의 DNS 서버에 등록 ⇒ 반복

- 예제: [`lab.glasscom.com`](http://lab.glasscom.com) 의 도메인을 담당하는 DNS서버를
    - [`glasscom.com`](http://lab.glasscom.com) 의 DNS에 등록
    - 상위의 DNS 서버에서 하위의 DNS 서버의 IP주소를 알 수 있고, 거기에서 조회 메시지를 보낼 수 있다.
- .com 이나 .kr 위에 루트 도메인이 존재, 마지막에 .이 찍혀있으면 그것이 루트도메인
    - 예제: [`lab.glasscom.com](http://lab.glasscom.com).`

## 4. DNS서버는 캐시 기능으로 빠르게 회답할 수 있다.

# 04 프로토콜 스택에 메시지 송신을 의뢰한다

---

## 1. 데이터 송수신 동작의 개요

Socket라이브러리를 이용한 데이터 송수신 동작을 표현하자면, 데이터를 송수신하는 컴퓨터 사이에 데이터의 통로 같은 것이 있고, 이것을 통해 데이터가 흐르며 양방향이다.

여기서 통로의 양끝을 데이터의 출입구인데 이 출입구를 소켓이라 부른다.

1. 먼저 서버측에서 소켓을 만들고 (소켓 작성 단계)
2. 클라이언트측에서도 소켓을 만든 후 클라이언트소켓에서 서버측 소켓으로 파이프로 연결  (접속 단계)
3. 모든 데이터의 송수신 (송수신 단계)
4. 송수신 동작이 끝나면 파이프를 분리하고 소켓을 말소하여 통신 동작 종료 (연결 끊기 단계)

## 2. 소켓의 작성 단계

DNS 서버의 경우 gethostbyname이라는 프로그램 부품(리졸버)을 호출했지만 이번에는 몇개의 프로그램 부품을 결정된 순번대로 호출

- 소켓을 만드는 방법은 소켓 라이브러리의 socket이라는 프로그램 부품을 호출
- 소켓이 생기면 디스크립터 라는 것이 돌아오므로 애플리케이션은 이것을 메모리에 기록
    - 디스크립터는 번호표 같은 것으로 애플리케이션은 디스크립터로 소켓을 식별

## 3. 파이프를 연결하는 접속 단계

만든 소켓을 서버측의 소켓에 접속하도록 프로토콜 스택에 의뢰

1. 애플리케이션은 소켓 라이브러리의 connect이라는 프로그램 부품을 호출
- connect 호출 시 지정하는 세가지 값
    - 디스크립터 : 애플리케이션이 소켓을 식별하는 것
    - 서버의 IP주소 : 송수신 하는 상대의 IP주소, like 전화번호
    - 포트 번호 : 전화번호만으로는 접속 불가하기 때문에 예를 들어 전화 후 00님 계십니까? 하여 원하는 상대를 찾는 중간 과정이 포트번호
- 서버 측 소켓의 디스크립터를 클라이언트에선 알 수 없으므로 포트번호가 필요한 것
- IP주소와 포트 번호 : 클라이언트와 서버간에 상대의 소켓을 식별하는 것

## 4. 메시지를 주고받는 송수신 단계

소켓 라이브러리의 write라는 프로그램 부품을 사용하여 소켓을 다룸

1. 우선 애플리케이션은 송신 데이터(URL을 바탕으로 반든 HTTP의 리퀘스트 메시지)를 준비
2. write를 호출할 때 디스크립터와 송신데이터를 지정
3. 프로토콜 스택이 송신 데이터를 서버에게 송신
4. 소켓에 연결의 기록이 있으므로 디스크립터로 소켓을 지정하면 연결된 상대를 판명하여 그곳에 데이터를 송신
5. 서버는 수신 동작을 실행하여 받은 데이터의 내용을 조사하고 적절한 처리를 실행하여 응답 메시지를 반송

소켓 라이브러리의 read라는 프로그램 부품을 통해 스포토콜 스택에 수신동작을 의뢰

## 5. 연결 끊기 단계에서 송수신이 종료된다.

브라우저가 데이터 수신을 완료하면 송수신 동작은 끝난다.

소켓 라이브러리의 close라는 프로그램 부품을 호출하여 연결 끊기 단계 의뢰

1. 응답메시지의 송신 완료 후 웹 서버측에서 close 호출하여 연결 끊기
2. 클라이언트측에 전달되어 클라이언트의 소켓 연결끊기 단계 돌입
3. 브라우저가 read로 수신동작을 의뢰했을 때 read는 수신데이터가 아니라 끊겼다는 사실을 통지
4. 브라우저도 close를 호출하여 연결끊기 단계에 돌입.

3~4 흐름

### **📌 전체 흐름 정리**

1️⃣ **DNS 조회 (리졸버 사용)**

- 브라우저가 `www.example.com`의 **IP 주소를 DNS 서버에 요청**
- DNS 서버가 IP 주소 (`192.168.1.1` 같은 형식)를 반환
- 이제 브라우저는 **도메인 대신 IP 주소를 사용**해서 서버에 연결 가능

2️⃣ **소켓을 이용해 서버와 연결**

- **소켓을 생성하고** `192.168.1.1` (웹 서버)로 연결 요청
- TCP/IP를 사용하여 **네트워크 연결 수립** (3-way handshake)

3️⃣ **HTTP 요청 메시지를 전송**

- `write()`를 사용해 **"GET /index.html HTTP/1.1"** 요청 전송
- 프로토콜 스택이 이 데이터를 **패킷(Packet)으로 변환해 전송**

4️⃣ **웹 서버가 요청을 처리하고 응답 반환**

- 웹 서버가 `GET` 요청을 받아서 `index.html` 데이터를 준비
- `HTTP/1.1 200 OK` + 웹 페이지 데이터를 클라이언트로 전송

5️⃣ **클라이언트(브라우저)가 응답을 해석하여 화면에 출력**

- 받은 HTML 데이터를 렌더링하여 웹 페이지를 표시