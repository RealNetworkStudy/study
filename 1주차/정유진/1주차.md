> 1주차
> **브라우저에 url을 입력하면, 브라우저에서 url(웹 서버)에 요청을 보낸다.**
> 
> 1. HTTP request 메시지를 작성한다.
> 2. 웹 서버(url)의 IP 주소를 DNS 서버에 조회한다.
> 3. 전 세계의 DNS 서버가 연대한다.
> 4. 프로토콜 스택에 메시지 송신을 의뢰한다.
> 
> <관련 키워드>
> IP 주소, DNS, Socket, 프로토콜 스택  
> 

## 1. HTTP request 메시지를 작성한다.

### 1) 브라우저는 가장 먼저 URL을 해독한다.

⇒ 서버와 파일명을 식별. 어디로 액세스할지

- URL = 프로토콜 + // + 서버명 + 데이터 출처 경로
    - 맨 앞은 데이터 출처에 엑세스하는 방법 = 프로토콜 종류 (http:, ftp:, file:, mailto: 등)

- 경로에서 파일명이 생략된 경우
    - (/로 끝나는 URL) 파일명을 생략하면 서버측 설정에 따라 대부분 ‘index.html’ 또는 ‘default.html’로 액세스 하게 됨
    - (경로명이 없는 경우) 루트 디렉토리 아래의 ‘index.html’ 또는 ‘default.html’
    - 웹 서버에 해당 파일이 있으면 파일로 보고, 디렉토리로 있으면 디렉토리명으로 봄  
<br/>

### 2) 브라우저는 리퀘스트 메시지를 만든다.

⇒ HTTP 프로토콜을 사용하여 웹 서버에 액세스한다.

**리퀘스트 메시지** 

- 리퀘스트 라인
    - <메소드> <URI> <HTTP 버전>
- 메세지 헤더
    - <필드명>:<필드값>
    - 마지막 <공백 행>
- 메세지 본문
    - 클라이언트에서 서버로 송신하는 데이터
    - GET인 경우 아무것도 없음
    - POST인 경우 폼에 입력한 데이터 등  
<br/>

### 3) 리퀘스트 메시지에 대한 응답이 돌아온다.

⇒ 응답 메시지가 되돌아오면, 데이터를 추출한 후 화면에 표시한다.

**응답 메시지**

- 스테이터스 라인
    - <HTTP 버전> <스테이터스 코드> <응답 문구>
- 메시지 헤더
    - <필드명>:<필드값>
    - 마지막 <공백 행>
- 메시지 본문
    - 서버에서 클라이언트로 송신하는 데이터  
<br/>   

**리퀘스트 메시지의 URI는 한 개만 가능하다.** 

ex) 한 문장에 3개의 영상 포함된 경우, 문장 파일 1 + 영상 파일 3 = 총 4개의 리퀘스트 메시지를 보내야 함.

`<img src=”image.jpg”>` 문서가 영상 등을 포함한 경우, 해당 부분은 비워두고 텍스트부터 모두 표시한 다음, 다시 한 번 웹 서버에 액세스 하여 영상 파일을 읽어와 표시한다. 

<br/>


## 2. 웹 서버의 IP 주소를 DNS 서버에 조회한다

⇒ 브라우저는 HTTP 메시지를 만들면, OS에 의뢰하여 액세스 대상의 웹 서버에 송신한다.

⇒ 이때 URL에 쓰여있는 서버의 도메인명을 IP주소로 변환해야 한다.

### 1) Socket 라이브러리가 IP 주소를 찾는 기능을 제공한다.

DNS 서버에 IP 주소를 조회한다는 것은, DNS 서버에 조회 메시지를 보내고, 반송되는 응답 메시지를 받는 것.

- DNS 클라이언트에 해당하는 것: DNS 리졸버
- DNS 원리를 사용하여 IP 주소를 조사하는 것을 네임 리졸루션이라고 한다

리졸버의 실체는 Socket 라이브러리의 프로그램

Socket 라이브러리는 OS에 포함된 네트워크 기능을 애플리케이션에서 호출하기 위한 것인데, 이 안에 리졸버가 포함된다.

<br/>

### 2) 브라우저는 리졸버를 이용하여 DNS 서버를 조회한다.

```jsx
<메모리 영역> = gethostbyname(”www.lab.cyber.co.kr”);
```

리졸버의 메소드(gethostbyname)과 웹 서버 이름으로 리졸버를 호출한다.

리졸버는 DNS 서버에 조회 메시지를 보내고, DNS 서버에서 응답 메시지가 돌아온다.

리졸버는 응답 메시지 속의 IP 주소를 추출하여 브라우저에서 지정한 메모리 영역에 저장한다.

브라우저는 이 메모리 영역에서 IP 주소를 사용하여 HTTP 리퀘스트 메시지와 함께 OS에 송신을 의뢰한다.

<br/>

### 3) 리졸버 내부의 작동

⇒ 리졸버는 DNS 서버에 문의하기 위한 조회 메시지를 만들고 DNS 서버에 보낸다.

- 메시지 송신 동작은 리졸버가 스스로 실행하는 것이 아니라, OS 내부에 포함된 프로토콜 스택을 호출하여 실행을 의뢰한다.  
(리졸버도 브라우저와 같이 네트워크에 대해 데이터를 송수신하는 기능이 없다.)
- LAN 어댑터를 통해 메시지가 DNS 서버로 송신된다.
- DNS 서버는 메시지에 쓰여있는 조회 내용을 조사하여 답을 찾는다.
- 액세스 대상의 웹 서버가 DNS 서버에 등록되어 있으면 답을 응답 메시지에 써서 클라이언트에 반송한다.
- 메시지는 네트워크를 통해 클라이언트측에 도착하고, 프로토콜 스택을 경유하여 리졸버에 건네진다.
- 리졸버 호출 시 지정한 메모리 영역에 IP 주소를 저장한다.
- 리졸버의 동작이 끝나고 제어가 브라우저로 돌아온다.

DNS서버에 메시지를 송신할 때도 DNS 서버의 IP 주소가 필요한데, 이는 컴퓨터에 설정되어 있음.

<br/>

## 3. 프로토콜 스택에 메시지 송신을 의뢰한다.

### 1) 데이터 송수신 동작의 개요

IP 주소를 조사한 후에는, 액세스 대상 웹 서버에 메시지를 송신하도록 OS 내부의 프로토콜 스택에 의뢰한다.

서버측은 소켓을 만들고, 소켓에 클라이언트가 파이프를 연결하기를 기다린다.  
서버측이 기다리는 동안, 클라이언트도 소켓을 만들고 파이프를 늘려 서버측의 소켓에 연결한다.  
이렇게 양쪽의 소켓이 연결되면 데이터 송수신 동작을 실행한다.  

이때 Socket 라이브러리 메소드를 순서대로 호출한다.  

1. 소켓을 만든다 (소켓 작성 단계)
2. 서버측의 소켓에 파이프를 연결한다 (접속 단계)
3. 데이터를 송수신한다 (송수신 단계)
4. 파이프를 분리하고 소켓을 말소한다(연결 끊기 단계)

실제 의뢰 동작은 [브라우저 → Socket 라이브러리 메소드 호출 → 프로토콜 스택]으로, Socket 라이브러리가 중개역을 수행함.  
실질적인 작업은 하지 않으므로, Socket라이브러리와 프로토콜 스택을 하나로 보고 동작을 이해하는 것이 쉽다.

```jsx
<메모리 영역> = gethostbyname("www.lab.cyber.co.kr");

<디스크립터> = socket(<IPv4 사용>, <스트림형>, ...);  // 준비

connect(<디스크립터>, <서버의 IP 주소와 포트 번호>, ...);  // 접속

write(<디스크립터>, <송신 데이터>, <송신 데이터 길이>);  // 송신

---

<수신 데이터 길이> = read(<디스크립터>, <수신 버퍼> ...);  // 수신

close(<디스크립터>);  // 연결 끊기
```
<br/>

### 1) 소켓 작성 단계

- `socket` 메소드를 호출하여 소켓을 만든다.
    
    디스크립터를 리턴하는데, 이는 소켓을 식별하기 위한 것이다.
    
    (컴퓨터 내부에는 여러 개의 소켓이 존재할 수 있기 때문에)
    

### 2)파이프를 연결하는 접속 단계

- `connect` 메소드를 호출하여, 만든 소켓을 서버측의 소켓에 접속하도록 프로토콜 스택에 의뢰
    - 디스크립터: 애플리케이션이 소켓을 식별
    - 서버의 IP주소와 포트번호: 클라이언트와 서버 간 상대의 소켓을 식별

### 3) 메시지를 주고받는 송수신 단계

- `write` 메소드를 호출하여 송신
    - 송신 데이터: HTTP 리퀘스트 메시지
    - 디스크립터: 소켓을 지정하면 연결된 상대를 알 수 있음
- `read` 메소드를 호출하여 수신
    - 수신 버퍼에 응답 메시지 저장

### 4) 연결 끊기 단계에서 송수신이 종료된다.

- `close` 메소드 호출하여 연결 끊기 단계로 들어감
    - HTTP 프로토콜에서는 응답 메시지를 송신하면, 웹 서버측에서 먼저 close()로 연결을 끊는다.
    - 이것이 클라이언트 측에 전달되어 클라이언트 소켓이 연결 끊기 단계로 들어간다.
    - 브라우저가 read할 때, 데이터를 건네주는 대신 연결이 끊겼다는 사실을 통지한다.
    - 브라우저도 close를 호출하여 연결 끊기 단계로 들어간다.