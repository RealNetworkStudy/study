# 2주차

# 01 소켓을 작성한다.

---

## 1 .프로토콜 스택의 내부 구성

- 프로토콜 스택의 내부
    
    ![image.png](image.png)
    
    - 애플리케이션
        - 네트워크 애플리케이션 (브라우저, 메일러, 웹서버, 메일 서버 등)
        - Socket 라이브러리
            - 리졸버
    - OS의 내부
        - 프로토콜 스택
            - TCP 프로토콜 : 브라우저나 메일 등 일반적인 애플리케이션이 데이터를 송수신 하는 경우
            - UDP 프로토콜 : DNS 서버에 대한 조회 등 짧은 제어용 데이터를 송수신 하는 경우
            - IP 프로토콜 : 패킷 송수신 동작을 제어
                - ARP : IP주소에 대응하는 이더넷의 MAC 주소를 조사할 때 사용
                - ICMP : 패킷을 운반할 때 발생하는 오류 통지, 제어용 메시지 통지
    - LAN 드라이버 : LAN 어댑터의 하드웨어를 제어
    - LAN 어댑터 : 실제 송수신 동작 실행

## 2 .소켓의 실체는 통신 제어용 제어 정보

- 프로토콜 스택
    - 내부에 제어정보를 기록하는 메모리 영역에 통신 동작을 제어하기 위한 제어 정보 기록
        - 통신 상대의 IP주소는 무엇인가
        - 포트 번호는 몇번인가
    - 메모리 영역 = 소켓의 실체
    - 송신 후 응답이 없는경우 일정시간이후 다시 보내야 하기 때문에
    - 소켓에는 응답이 돌아오는지의 여부, 송신 동작 후의 경과시간이 기록
    - 프로토콜 스택은 이 정보를 보고 다시 보내는 동작 실행
    - 프로토콜 스택은 소켓에 기록된 제어 정보를 참조하며 움직인다.

## 3 .Socket을 호출했을 때의 동작

- 소켓을 만드는 단계
    - 애플리 케이션이 socket을 호출하며 만들 것 의뢰
    - 프로토콜 스택은 소켓 한개 분량의 메모리 영역 확보
    - 프로토콜 스택이 한개의 socket을 만듦
- 만들어 진 후
    - 소켓을 나타내는 디스크립터(번호표)를 애플리케이션에 알려줌

# 02 서버에 접속한다

---

## 1 .접속의 의미

- 소켓을 만든직후 애플리케이션에서 데이터 송신 의뢰가 올 경우
    - 아무 기록이 없어 통신 상태가 누군지 모르는 상태 이기 때문에 데이터를 어디로 보내는지도 모름
- 접속 동작
    - 통신 상대와의 사이에 제어 정보를 주고받아 소켓에 필요한 정보를 기록하고 데이터 송수신이 가능한 상태로 만드는 것
        - 클라이언트측의 IP주소나 포트번호를 서버측에 알리는 것
    - 제어 정보 : 송수신 동작을 제어하기 위한 정보
        - IP주소
        - 포트 번호 등등
    - 버퍼 메모리 확보
        - 데이터 송수신 시 일시적으로 저장하는 메모리 영역

## 2. 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다

- 제어 정보
    1. 헤더에 기입되는 정보
        - 클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 제어 정보
        - TCP 프로토콜의 사양으로 규정
        - TCP 헤더 : 클라이언트와 서버가 대화할 때 마다의 제어 정보를 배치하는 패킷의 맨 앞
    2. 소켓에 기록되는 정보
        - 소켓에 기록하여 프로토콜 스택의 동작을 제어하기 위한 정보
        - 애플리케이션에서 통지된 정보, 통신 상대로부터 받은 정보 등 수시로 기록
    - 소켓에 기록한 제어 정보는 상태측에서 볼 수 없음

## 3. 접속 동작의 실제

(TCP 3-Way Handshake 과정)

- **클라이언트 → 서버**
    - 서버의 **IP 주소와 포트 번호**를 이용해 TCP 담당 부분에 접속 요청
    - TCP 헤더 생성, **SYN 비트를 1**로 설정 (SYN 패킷 전송)
    - IP 담당 부분에 전달하여 패킷 전송
- **서버 → 클라이언트**
    - 서버는 **IP 담당 부분**에서 패킷을 받아 **TCP 담당 부분**으로 전달
    - 요청받은 **포트 번호가 유효하면** 연결 수락 준비
    - 응답 패킷 생성, **SYN=1, ACK=1**로 설정 (SYN-ACK 패킷 전송)
- **클라이언트 → 서버**
    - 클라이언트가 SYN-ACK 패킷을 수신하면 연결 준비 완료
    - **ACK=1**로 설정된 응답 패킷 전송 (ACK 패킷)
    - 서버가 ACK 패킷을 받으면 **연결이 완료**됨

# 03 데이터를 송수신한다

---

## 1. 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다

- **HTTP 요청 전달**
    - 애플리케이션에서 `connect()`를 호출하여 TCP 연결이 완료되면, 데이터 송수신이 시작됨
    - 애플리케이션이 `write()`를 호출하여 **HTTP 요청 메시지를 프로토콜 스택**에 전달
- **TCP 프로토콜 스택에서 송신 처리**
    - 프로토콜 스택이 **송신 동작을 실행**
    - 데이터를 적절한 크기로 나누어 패킷을 생성
- **패킷화 (데이터 크기 결정)**
    - **MTU (Maximum Transmission Unit):** 패킷 한 개가 운반할 수 있는 최대 크기 (보통 **1500바이트** in 이더넷)
    - **MSS (Maximum Segment Size):** TCP에서 헤더를 제외한 데이터 크기 (보통 **1460바이트**)
    - MTU보다 큰 데이터는 여러 개의 패킷으로 분할
- **타이밍 (전송 트리거)**
    - **버퍼가 가득 차면 전송**
    - 작은 데이터는 **Nagle 알고리즘**이 모아서 전송
    - **타이머 기반 전송:** 일정 시간이 지나면 패킷 강제 전송
    - **TCP 윈도우 크기 조절:** 수신 측에서 처리 가능한 만큼만 전송
- **절충 (최적의 송신 전략)**
    - **패킷을 최대한 크게 유지하여 전송 횟수 감소**
    - **타이밍 조절하여 작은 데이터는 모아서 보내고, 지연 최소화**
    - 효율적인 **TCP 흐름제어**와 **윈도우 크기 조정**을 통해 속도와 신뢰성을 조율

## 2. 데이터가 클 때는 분할하여 보낸다

한 패킷에 들어가지 않을 만큼 긴 데이터는 맨 앞부터 MSS 크기에 맞게 분할하고, 분할한 조각을 한 개씩 패킷에 넣어 송신

## 3. ACK 번호를 사용하여 패킷이 도착했는지 확인한다

- 데이터 분할 (패킷화)
    - TCP 담당 부분이 데이터를 조각으로 나누며, 각 조각이 통신 시작부터 몇 번째 바이트인지 계산
    - 각 조각에 시퀀스 번호(Sequence Number)를 부여하여 데이터 순서를 추적
- 패킷 생성 및 전송
    - TCP 헤더에 시퀀스 번호를 기록하고 패킷을 생성
    - 패킷 전체 길이에서 헤더 크기를 제외하면 실제 데이터 크기를 계산 가능
    - IP 담당 부분에 전달 후 네트워크로 송신
- 수신 측에서 패킷 확인
    - 패킷이 도착하면 시퀀스 번호를 확인하여 데이터 조각의 순서를 파악
    - 데이터 크기를 계산하여 정상적으로 도착했는지 확인
- ACK 번호를 통한 수신 확인 및 응답
    - 수신 측은 정상적으로 받은 데이터를 기준으로 ACK(Acknowledgment) 번호를 생성
    - ACK 번호 = 수신한 마지막 바이트의 시퀀스 번호 + 다음 기대하는 바이트의 번호
    - 이 정보를 포함한 ACK 패킷을 송신 측으로 전송
- 송신 측에서 응답 확인 후 다음 데이터 전송
    - 송신 측은 ACK 번호를 확인하여 해당 패킷이 제대로 도착했는지 판단
    - ACK을 받으면 다음 데이터를 계속 전송
    - 중간에 패킷이 유실되면, 해당 패킷부터 재전송(Retransmission)

## 4. 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다

- ACK 번호가 돌아오는 것을 기다리는 대기시간 = 타임아웃 값
- 데이터 송신 동작을 실행하며 ACK 번호가 돌아오는 시간이 지연되면 대응하여 대기시간도 늘리고
- 바로 돌아오면 대기시간을 짧게 설정하며 TCP는 동적으로 변경하는 방법을 취함

## 5. 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다

- ACK 번호가 돌아올 때까지의 시간 낭비를 줄이기 위해 **윈도우 제어**라는 방식에 따라 송신과 ACK 번호 통지의 동작을 실행
- 윈도우 제어 = 한개의 패킷을 보낸 후 ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보내는 방법
    - 하지만 너무 빠른 속도로 데이터가 도착하면 수신버퍼에 데이터가 넘치게 되고, 넘친 데이터는 없어져버리므로 오류가 생김 → 이것을 해결하기 위해 먼저 수신측에서 송신측에 수신 가능한 데이터 양을 통지하고, 수신측은 이 양을 초과하지 않도록 송신 동작을 실 행 = > 윈도우 제어 방식의 개념
    - 수신측에서 더 많은 데이터를 받을 수 있다면 TCP 헤더의 **윈도우 필드**에서 이것을 송신측에 알림
- 윈도우 사이즈 = 수신 가능한 데이터 양의 최대값, TCP를 정밀 조정하는 매개변수의 하나

## 6. ACK 번호와 윈도우를 합승한다

- ACK 번호로 수신된 패킷을 확인하고, 동시에 윈도우 크기를 조정하여 데이터 흐름을 관리
- 이를 한 패킷에 합쳐 보내면서 통신 효율을 높이고, 불필요한 패킷 전송을 줄임

## 7. HTTP 응답 메시지를 수신한다.

- 서버가 HTTP 응답 메시지를 생성하여 TCP를 통해 전송
- 클라이언트는 패킷을 수신하고 시퀀스 번호를 확인하여 재조립
- ACK와 윈도우 크기 정보를 포함한 응답을 서버에 전송
- 최종적으로 웹 브라우저 등 애플리케이션이 응답을 받아 처리

⇒ 이 과정으로 웹페이지가 정상적으로 로드

# 04 서버에서 연결을 끊어 소켓을 말소한다.

---

## 1. 데이터 보내기를 완료했을 때 연결을 끊는다.

(4-Way Handshake 과정)

- 서버측에서 연결 끊기 단계에 들어가는 경우
1. **서버에서 연결 종료 요청**
    - 서버 애플리케이션이 `close()` 호출
    - 프로토콜 스택이 TCP 헤더를 생성하고 **FIN 비트를 1**로 설정하여 연결 종료 요청
    - IP 담당 부분을 통해 **FIN 패킷을 클라이언트로 전송**
    - 서버 측 소켓은 **연결 종료 절차에 들어갔다고 기록**
2. **클라이언트가 FIN 패킷 수신**
    - 클라이언트 측 TCP 스택이 **FIN 패킷을 수신**하면,**서버가 연결 종료를 요청했음을 소켓에 기록**
    - 수신 확인을 위해 **ACK 패킷을 서버로 전송**
3. **클라이언트가 남은 데이터 처리**
    - 애플리케이션이 `read()`를 호출하여 남아있는 데이터를 가져옴
    - 모든 데이터 수신이 완료되면 클라이언트 애플리케이션(브라우저)도 `close()` 호출
4. **클라이언트에서 최종 연결 종료 요청**
    - 클라이언트도 **FIN 패킷을 서버로 전송**하여 연결 종료 요청
    - 서버가 **ACK 패킷을 클라이언트로 반송**하면 연결 종료 절차 완료

## 2. 소켓을 말소한다.

오작동을 막기위해 잠시 기다린 후 말소(=패킷을 다시 보내는 동작과 관계)

## 3. 데이터 송수신 동작을 정리한다.

![image.png](image%201.png)

# 05 IP와 이더넷의 패킷 송수신 동작

---

## 1. 패킷의 기본

- 패킷은 ‘헤더’ 와 ‘데이터’ 두부분으로 구성
    - 이더넷의 패킷 : MAC 헤더 + IP 헤더 + TCP 헤더 + 데이터 조각
    - IP의 패킷 : IP 헤더 + TCP 헤더 + 데이터 조각
- 송신처와 수신처의 중계장치
    - 패킷의 송신처가 되는 기기에서 패킷 생성 후 헤더,데이터에 정보기록 후 가장 가까운 중계 장치로 송신
    - 중계 장치는 패킷의 헤더를 조사 후 목적지를 판단
    - 이때 중계장치 안에 어느 수신처가 어디에 있는지가 기록된 표 같은 것이 있어서 이것을 바탕으로 목적지 판단
    - 00번주소는 000번째 케이블 이라는 정보를 얻고 000번째 케이블로 정보 송신
    - 패킷은 다음 중계 장치에 도착
    - 반복하여 최종적으로 수선처의 기기에 패킷이 도착
- TCP/IP의 패킷 구조
    - 라우터가 목적지를 확인하여 다음 라우터를 나타냄
    - 허브가 서브넷 안에서 패킷을 운반하여 다음 라우터에 도착
    - ⇒ 라우터는 IP규칙, 러브는 이더넷 규칙을 따르기 때문에 달리 말하면
    - IP가 목적지를 확인하여 다음 IP의 중계장치를 나타냄
    - 서브넷 안에 있는 이더넷이 중계장치까지 패킷을 운반
    - ⇒ IP주소는 IP 헤더에, 이더넷의 주소(MAC 주소)는 MAC헤더에
- TCP/IP 패킷
    - 송신처에서 패킷의 목적지가 되는 액세스 대상 서버의 IP 주소를 IP헤더의 수신처에 기록
    - IP는 수신처가 어느방향에 있는지, 그 방향에 있는 다음 라우터 (R1)조사
    - 다음 라우터를 확인하면 이더넷에 의뢰
    - 다음 라우터에 할당된 이더넷의 주소를 MAC헤더에 기록
    - 이후 패킷 송신하여 허브에 도착
    - 허브에는 패킷의 목적지를 판단하기 위한 표 같은 것이 있어서 목적지 판단 중계
    - 패킷은 다음 라우터(R1)에 도착
    - 다음 라우터에 IP용 표가 있으므로 IP헤더의 수신처와 결합하여 다음 라우터 결정, 다음라우터의 이더넷 주소를 MAC헤더에 기록
    - 다음 허브 경유하여 다음라우터 R2 도착
    - 반복하여 목적지에 패킷이 도착

## 2. 패킷 송수신 동작의 개요

- 프로토콜 스택의 IP담당 부분의 패킷 송신 동작
    - TCP 담당 부분은 데이터 조각에 TCP 헤더를 부가한 것을 IP담당 부분에게 건네준다(이것은 패킷에 들어가는 내용물이자 통신 상대의 IP주소) = ‘ 이 상대에게 이 내용물을 전달해 주세요 ‘ 라는 뜻
    - IP담당 부분은 이 디지털 데이터 앞에 제어정보를 기록한 헤더를 부가, IP헤더와 MAC헤더
        - IP헤더 : IP주소로 표시된 목적지까지 패킷을 전달할 때 사용하는 제어 정보를 기록
        - MAC헤더 : 이더넷 등의 LAN을 사용하여 가장 가까운 라우터까지 패킷을 운반할때 사용하는 제어정보
    - 만든 패킷을 네트워크용 하드웨어(이더넷, 무선 LAN 등) 에 건네줌
    - 이때의 패킷은 0이나 1의 비트가 이어진 디지털 데이터이며, 이것이 LAN 어댑터에 의해 전기나 빛의 신호 상태로 바뀌어 케이블에 송출
    - 신호는 허브나 라우터 등의 중계장치에 도착, 중계장치가 상대가 있는 곳까지 패킷 전달
    - 도착하면 회답이 돌아오는데(수신 동작은 송신동작의 반대)
    - 여기서는 신호의 모습의 패킷이 LAN어댑터에서 디지털 데이터의 모습으로 되돌림
    - 디지털데이터의 패킷을 IP담당 부분이 받고
    - IP담당 부분이 TCP헤더와 데이터 조각을 TCP담당 부분에 건네줌
- IP가 패킷을 송수신 하는 동작은 제어 패킷이든지, 데이터 패킷이든지 패킷의 역할에 상관 없이 모두 같다

## 3. 수신처 IP주소를 기록한 IP헤더를 만든다

### **IP 담당 부분과 패킷 송수신 과정 정리**

1. **IP 헤더 생성 및 설정**
    - TCP 담당 부분에서 **패킷 송수신 의뢰**를 받으면, **IP 담당 부분**이 **IP 헤더를 생성**
    - **IP 헤더에는 가장 중요한 정보인 수신처 IP 주소를 포함**
    - 송신처 IP 주소도 설정하여 패킷의 출발지를 명확히 함
2. **IP의 역할**
    - IP는 패킷을 단순히 지정된 수신처로 전송할 뿐, 수신처가 올바른지 직접 판단하지 않음
    - 애플리케이션이 지정한 IP 주소를 그대로 사용하여 IP 헤더에 설정
    - 잘못된 IP 주소가 설정되면 그대로 전송되므로, 올바른 주소 지정이 중요
3. **LAN 어댑터와 라우터 결정**
    - 대부분의 컴퓨터는 LAN 어댑터가 하나여서 **할당된 IP 주소도 하나**지만, 여러 개의 IP를 가질 수도 있음
    - 패킷을 전송할 때 **어떤 LAN 어댑터를 사용할지 결정하는 것은 경로(Route) 설정과 동일**
    - 패킷을 전송할 때 **어떤 라우터(게이트웨이)를 통해 보낼지 결정**하는 과정이 포함됨
4. **경로 결정 (라우팅)과 기본 게이트웨이**
    - **IP 패킷의 전송 경로는 "경로표(Routing Table)"를 참고하여 결정**
    - 경로표를 조회하여 **수신처 IP가 동일 네트워크인지 확인**
        - 동일 네트워크(서브넷 내)라면, 직접 해당 기기로 전송
        - 다른 네트워크라면 **기본 게이트웨이(Default Gateway)로 전달**
    - **기본 게이트웨이**는 다른 네트워크로 패킷을 보낼 때 중계하는 역할
5. **넷마스크(Netmask)와 네트워크 구분**
    - IP 주소에서 네트워크와 호스트 부분을 구분하기 위해 **넷마스크(Netmask)** 사용
    - **수신처 IP와 송신처 IP의 네트워크 주소를 비교하여**
        - 같은 네트워크라면 **직접 전송**
        - 다른 네트워크라면 **기본 게이트웨이를 통해 전송**
6. **프로토콜 번호 설정**
    - IP 헤더에는 상위 계층 프로토콜(TCP, UDP 등)을 구별하기 위한 **프로토콜 번호** 포함
    - **TCP는 6, UDP는 17** 등으로 설정하여 수신 측이 어떤 프로토콜인지 식별 가능

## 4. 이더넷용 MAC 헤더를 만든다

- 이더넷의 수신처 판단 구조로 사용하는 것이 MAC 헤더
    - IP 담당 부분은 IP헤더를 붙였으면 그 앞에 MAC 헤더를 붙입니다. MAC 헤더는 이더넷에서 사용하는 헤더로서 수신처나 송신처의 MAC 주소 등이 기록되어 있습니다.
- MAC 헤더의 맨 앞에 있는 수신처 MAC 주소와 그 다음의 송신처 MAC 주소는 각각 패킷을 전달하는 상대와 패킷을 송신한 송신처의 MAC 주소를 나타낸다.
- IP주소는 32비트, MAC 주소는 48비트
- MAC 헤더
    - 이너타입 필드
    - 송신처 MAC 주소
    - 수신처 MAC 주소

## 5. ARP로 수신처 라우터의 MAC 주소를 조사한다.

- 이더넷에서 상대의 MAC 주소를 알고 MAC 헤더를 만들어 패킷을 보낼 때마다 ARP의 패킷이 불어나기 때문에 ARP 캐시라는 메모리 영역에 보존하여 다시 이용
- 하지만 ARP 캐시에 저장된 MAC 주소가 무조건 같지 않을 경우가 있기 때문에 시간에 따라 저장된 값이 삭제하게 되어 있음.
- MAC 주소를 조사할 때는 ARP를 사용한다.

# 06 UDP 프로토콜을 이용한 송수신 동작

---

## 1. 수정 송신이 필요없는 데이터의 송신은 UDP가 효율적이다.

- TCP가 복잡한 이유는 데이터를 확실하면서도 효율적으로 전달하기 위해서  , 도착한 것을 확인하고 도착하지 않으면 다시 보내야 한다.
- UDP는 전부 보낸 후 수신측에 수신확인 응답을 받으면 된다. 하지만 패킷이 한개만 없어져도 전체를 다시 보내야 하기 때문에 비효율적

## 2. 제어용 짧은 데이터

- DNS 서버에 대한 조회 등 제어용으로 실행하는 정보 교환은 한개의 패킷으로 끝나는 경우가 많으므로 UDP 사용
- 애플리케이션에서 송신 데이터를 받으면 UDP 헤더를 부가하고 이것을 IP에 의뢰하여 송신하기만 하면 됨.
- 수신도 IP헤더에 기록된 수신처 IP 주소와 송신처 IP주소, 그리고 UDP 헤더에 기록되어 있는 수신처 포트 번호, 송신처 포트 번호라는 네 항목과 소켓에 기록된 정보를 결합하여 데이터를 건네줄 대상 애플리케이션을 판단하고 여기에 데이터를 건네주기만 함.
- 오류발생으로 회답이 없다면 같은 데이터를 한번 더 보내기

## 3. 음성 및 동영상 데이터

- 음성이나 영상의 데이터를 보낼 때도 UDP를 사용
