# 클라이언트가 보낸 패킷이 서버로 도착한 직후
서버 측으로 들어온 패킷의 경우 사실 '전기 신호'의 형태로 들어온다.
전기 신호는 LAN 어댑터에서 수신되며, 여기서 1과 0의 디지털 데이터로 바뀌게 된다.
1. 변경된 디지털 데이터에서 패킷의 가장 마지막단에 있는 FCS (Frame Check Sequence)를 통해 오류의 유무를 검사 
2. 데이터가 무결하다면 맨 앞에 있는 MAC 헤더에 있는 수신처의 MAC 주소를 확인해서 본인에게 온 데이터인지 체크
3. LAN 어댑터 내부의 버퍼에 저장해두고, 인터럽트를 통해서 CPU에게 패킷이 도착했음을 알림.
4. CPU는 하던 작업을 중단하고 LAN 드라이버를 통해 LAN 어댑터의 버퍼 메모리에서 수신한 패킷을 추출
5. MAC 헤더의 타입 필드를 통해 프로토콜을 판별
6. 해당 프로토콜을 처리할 수 있는 소프트웨어를 호출

### 전기 신호에서 디지털 데이터로 변환되었을 때 패킷의 형태
![image.png](https://github.com/RealNetworkStudy/study/blob/main/2%EC%A3%BC%EC%B0%A8/%EC%96%B4%EC%9D%80%EC%A7%80/DigitalTypePacket.png)

#  프로토콜 스택과 IP 담당 부분
7. 프로토콜 스택까지 패킷이 오게 되면 IP 담당 부분이 IP 헤더를 점검
8. IP 헤더에서 수신처 IP 주소를 통해 본인에게 보내는 패킷인지 체크
9. 패킷이 잘 분할되었는지 체크하고 (IP 헤더의 플래그 값을 통해 확인) 분할된 패킷이 모두 도착할 때까지 메모리에 저장
10. 전부 도착하게 되면 재조립하여 원래의 패킷으로 복원을 하고, 프로토콜 번호 항목에 따라서 TCP or UDP or ICMP 담당 부분에게 패킷을 전달

# 서버에서 소켓을 받는 과정 - 소켓 메서드로 분석하기
* 보통 서버와 클라이언트는 1:1로 접속하여 대화하는 것이 일반적
* 보통 멀티스레드를 통해서 작동
* 클라이언트의 접속을 대기할 때 새로운 스레드를 생성하고 접속 시 새로 생성한 소켓을 건네줌
* 운영체제의 커널 내부에 소켓을 관리하는 정보가 담겨있기 때문에, 해당 정보를 바탕으로 클라이언트에게 소켓 정보가 분배

```
 클라이언트의 데이터 송-수신 과정
  1. 소켓 작성
  2. 서버의 소켓과 파이프로 연결 (접속)
  3. 데이터 송-수신
  4. 파이프 분리 후 소켓 말소 (연결 끊기)

```
```
 서버 데이터 송-수신 과정
  1. 소켓 작성
  2-1. 소켓을 접속 대기 상태로 만들기
  2-2. 소켓 접속에 대해 접수 
  3. 데이터 송-수신
  4. 파이프 분리 후 소켓 말소 (연결 끊기)

```
## 클라이언트의 소켓 연결 프로세스와 비슷하지만, bind, listen, accept 같은 코드 추가\

1. bind : 소켓에 주소를 할당하기
2. listen: 연결 요청을 대기하기
3. accept: 연결 요청 수락하기

```java
int bind(int sockfd, struct sockaddr *addr, socklen_t addrlen);
int listen(int sock, int backlog);
int accept(int sock, struct sockaddr*addr, socklen_t *addrlen);

```
* bind 메서드의 경우 총 3개의 인자를 받는다.
  * 첫 번째 인자의 경우 socket()을 통해 받아오는 디스크립터
  * 두 번째 인자의 경우 IP 주소와 포트 번호를 담고 있는 구조체
  * 세 번째 인자의 경우 주소 정보를 담은 변수의 길이
  * 바인딩이 성공하면 0을, 실패하면 -1을 반환

* listen이 호출된 이후부터 클라이언트는 connect를 통해서 서버로 연결을 요청할 수
  * 첫 번째 인자는 소켓 디스크립터의 번호
  * 두 번째 인자는 연결 요청을 대기하고 있는 큐의 크기
  * 클라이언트가 연결을 요청했을 때 요청이 온 순서대로 처리할 수 있도록 클라이언트를 큐에 담아두고 모아둔 곳
 
* 대기 중인 클라이언트의 요청을 차례대로 수락
  * 첫 번째 인자는 기존의 디스크립터 번호
  * 두 번째 인자는 대기 큐에서 얻어온 클라이언트의 주소 정보
  * 세 번째 인자는 addr 변수의 크기를 의미
  * 만약, 대기 큐가 비어있다면 accept은 반환되지 않고 새로운 요청이 올 때까지 blocking 상태
* accept은 기존의 디스크립터가 아닌, 새로운 디스크립터를 (디스크립터 2) 반환
  * 앞에서 사용했던 디스크립터는 연결 요청에 대한 대기까지만 진행
  * accept을 통해 새롭게 할당받은 디스크립터를 통해 실제 클라이언트와 데이터 송-수신 과정을 진행할 수 있다.
  * 기존의 디스크립터를 사용하면 접속 대기 소켓이 사라지게 되어서 다음에 다른 클라이언트가 접속시 이미 소켓이 연결된 상태로 해당 요청을 처리할 수 없다.
### 클라이언트의 요청이 올 때마다 새로운 소켓을 생성하여 해당 클라이언트의 통신과를 담당하도록 만들지만 포트 번호는 유지
포트 번호를 유지하게 된다면 하나의 포트 번호에 여러 개의 소켓이 존재할 수도 있다. (접속 대기 용도 / 데이터 송-수신 용도) 클라이언트에서 패킷이 도착했을 때 단순히 포트 번호로 어떤 소켓이랑 대화하고 있는지 알 수 없다. 따라서 아래와 같은 추가 정보로 소켓을 식별한다. 클라이언트 측은 모두 다른 포트 번호를 할당하고, IP주소까지 합하 각 소켓들이 충분히 식별가능해진다.
- 클라이언트의 IP 주소
- 클라이언트의 포트 번호
- 서버측의 IP 주소
- 서버측의 포트 번호

### 소켓을 만든 직후 접속 동작을 하기 전에는 클라이언트의 IP, 포트 번호를 알 수 없다.
### 서버에서 소켓을 받는 과정 - TCP 헤더의 관점에서 분석하기










---
출처: https://cl8d.tistory.com/107 [DevLog 😶:티스토리]
